<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Трекер тренировок</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    /* CSS Variables */
    :root {
    --bg: #0f1115;
    --card: #171a21;
    --card2: #131720;
    --text: #e6e9ef;
    --muted: #9aa4b2;
    --line: #2a2f3a;
    --acc: #4f8cff;
    --danger: #ef4444;
    --ok: #22c55e;
    --input-bg: #0f1320;
    
    --spacing-xs: 6px;
    --spacing-sm: 8px;
    --spacing-md: 12px;
    --spacing-lg: 16px;
    
    --radius-sm: 8px;
    --radius-md: 10px;
    --radius-lg: 12px;
    --radius-xl: 16px;
    
    --header-height: 60px;
    --footer-height: 84px;
    --modal-max-width: 520px;
    }

    /* Reset & Base Styles */
    * { 
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    }

    body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    padding-bottom: var(--footer-height);
    line-height: 1.5;
    }

    /* Header Styles */
    header {
    position: sticky;
    top: 0;
    z-index: 10;
    background: var(--card);
    border-bottom: 1px solid var(--line);
    padding: var(--spacing-md);
    }

    h1 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    }

    .muted {
    color: var(--muted);
    font-size: 13px;
    }

    /* Controls */
    .controls {
    margin-top: var(--spacing-sm);
    display: flex;
    gap: var(--spacing-sm);
    align-items: center;
    flex-wrap: wrap;
    }

    /* Form Elements */
    input[type="date"] {
    background: var(--card2);
    border: 1px solid var(--line);
    color: var(--text);
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--radius-sm);
    font-size: 14px;
    }

    button {
    background: var(--acc);
    color: #fff;
    border: none;
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--radius-sm);
    font-weight: 600;
    cursor: pointer;
    transition: opacity 0.2s;
    }

    button:hover {
    opacity: 0.9;
    }

    button:active {
    opacity: 0.8;
    }

    button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    }

    button.ghost {
    background: transparent;
    border: 1px solid var(--line);
    color: var(--text);
    }

    button.danger {
    background: var(--danger);
    }

    /* Main Content */
    main {
    padding: var(--spacing-md);
    max-width: 1200px;
    margin: 0 auto;
    }

    /* Tabs */
    .tabs {
    margin-top: var(--spacing-md);
    display: flex;
    gap: var(--spacing-sm);
    flex-wrap: wrap;
    }

    .tab-btn {
    background: transparent;
    border: 1px solid var(--line);
    color: var(--text);
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: 999px;
    font-weight: 600;
    cursor: pointer;
    }

    .tab-btn.active {
    background: var(--acc);
    border-color: var(--acc);
    }

    .tab {
    display: none;
    }

    .tab.active {
    display: block;
    }

    /* Stats Section */
    .stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    }

    @media (max-width: 420px) {
    .stats {
    grid-template-columns: repeat(2, 1fr);
    }
    }

    .stat {
    background: var(--card2);
    border: 1px solid var(--line);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    text-align: center;
    }

    .stat h3 {
    margin: 0;
    font-size: 13px;
    color: var(--muted);
    font-weight: normal;
    }

    .stat p {
    margin: var(--spacing-xs) 0 0;
    font-size: 16px;
    font-weight: 700;
    }

    /* Exercise Blocks */
    .blocks {
    display: grid;
    gap: var(--spacing-md);
    }

    .block {
    background: var(--card);
    border: 1px solid var(--line);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
    }

    .block-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
    border-bottom: 1px solid var(--line);
    padding-bottom: var(--spacing-xs);
    }

    .block-title {
    font-weight: 700;
    font-size: 15px;
    }

    .block-actions {
    display: flex;
    gap: var(--spacing-sm);
    flex-wrap: wrap;
    }

    .exercise-name {
    width: 100%;
    background: var(--input-bg);
    border: 1px solid var(--line);
    color: var(--text);
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--radius-sm);
    margin-bottom: var(--spacing-sm);
    }

    .exercise-name::placeholder {
    color: var(--muted);
    }

    /* Exercise Sets */
    .sets {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: var(--spacing-sm);
    }

    .set {
    background: var(--input-bg);
    border: 1px solid var(--line);
    border-radius: var(--radius-sm);
    padding: var(--spacing-sm);
    position: relative;
    }

    .set .num {
    font-size: 11px;
    color: var(--muted);
    margin-bottom: var(--spacing-xs);
    text-align: center;
    }

    .set .row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--spacing-sm);
    align-items: center;
    }

    .set .rm {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: var(--danger);
    color: white;
    border: none;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    }

    /* Number Input */
    .num-input {
    display: flex;
    align-items: center;
    background: var(--input-bg);
    border: 1px solid var(--line);
    border-radius: var(--radius-sm);
    overflow: hidden;
    height: 36px;
    }

    .num-input button {
    width: 36px;
    height: 100%;
    background: transparent;
    border: none;
    color: var(--text);
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    }

    .num-input .value {
    flex: 1;
    text-align: center;
    font-weight: 700;
    cursor: pointer;
    user-select: none;
    }

    .num-input .unit {
    width: 44px;
    text-align: center;
    font-size: 12px;
    color: var(--muted);
    border-left: 1px solid var(--line);
    }

    /* History & Stats */
    .empty {
    text-align: center;
    color: var(--muted);
    padding: var(--spacing-lg);
    }

    .history-item {
    background: var(--card2);
    border: 1px solid var(--line);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
    cursor: pointer;
    transition: background-color 0.2s;
    }

    .history-item:hover {
    background: var(--card);
    }

    .history-item .date {
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
    }

    .history-item .stats {
    display: flex;
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-xs);
    }

    .history-item .stat {
    display: flex;
    gap: var(--spacing-xs);
    background: none;
    border: none;
    padding: 0;
    font-size: 12px;
    }

    .history-item .exercises {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-xs);
    }

    .history-item .exercise {
    background: var(--input-bg);
    padding: 2px 6px;
    border-radius: var(--radius-sm);
    font-size: 11px;
    color: var(--muted);
    }

    .stat-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    }

    .card {
    background: var(--card2);
    border: 1px solid var(--line);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    }

    .card h3 {
    margin: 0 0 var(--spacing-sm);
    font-size: 14px;
    color: var(--muted);
    font-weight: normal;
    }

    .metric {
    font-size: 20px;
    font-weight: 700;
    }

    .list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-sm) 0;
    border-bottom: 1px solid var(--line);
    }

    .list-item:last-child {
    border-bottom: none;
    }

    .list-item .name {
    font-weight: 500;
    }

    .list-item .stats {
    display: flex;
    gap: var(--spacing-md);
    font-size: 12px;
    color: var(--muted);
    }

    .list-item .value {
    font-weight: 600;
    color: var(--text);
    }

    /* Modal Styles */
    .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 100;
    padding: var(--spacing-md);
    }

    .modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
    }

    .sheet {
    background: var(--card);
    border-radius: var(--radius-xl);
    width: 100%;
    max-width: var(--modal-max-width);
    max-height: 90vh;
    overflow: hidden;
    animation: slideUp 0.3s ease-out;
    }

    @keyframes slideUp {
    from { transform: translateY(100%); }
    to { transform: translateY(0); }
    }

    .sheet-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spacing-md);
    border-bottom: 1px solid var(--line);
    }

    .sheet-title {
    font-weight: 600;
    font-size: 16px;
    }

    .sheet-actions-inline {
    display: flex;
    gap: var(--spacing-sm);
    }

    .sheet-content {
    padding: var(--spacing-md);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    max-height: calc(90vh - 60px);
    }

    .picker-item {
    padding: 10px;
    text-align: center;
    cursor: pointer;
    }

    .picker-item[aria-selected="true"] {
    color: var(--acc);
    font-weight: bold;
    }

    .center-line {
    position: relative;
    height: 200px;
    overflow: auto;
    }

    .picker {
    padding: 80px 0;
    }

    .workout-summary .date {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: var(--spacing-md);
    text-align: center;
    }

    .workout-summary .stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-md);
    }

    .workout-summary .stat {
    text-align: center;
    padding: var(--spacing-sm);
    background: var(--input-bg);
    border-radius: var(--radius-sm);
    }

    .workout-summary .label {
    font-size: 12px;
    color: var(--muted);
    }

    .workout-summary .value {
    font-weight: 600;
    }

    .workout-summary .block {
    margin-bottom: var(--spacing-md);
    padding: var(--spacing-md);
    background: var(--input-bg);
    border-radius: var(--radius-md);
    }

    .workout-summary .exercise {
    margin-bottom: var(--spacing-sm);
    }

    .workout-summary .exercise .name {
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
    }

    .workout-summary .sets {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: var(--spacing-xs);
    }

    .workout-summary .set {
    background: var(--card2);
    border-radius: var(--radius-sm);
    padding: var(--spacing-xs);
    text-align: center;
    font-size: 12px;
    }

    /* Footer Actions */
    .page-actions {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--card);
    border-top: 1px solid var(--line);
    padding: var(--spacing-sm) var(--spacing-md);
    display: flex;
    gap: var(--spacing-sm);
    z-index: 9;
    }

    .page-actions button {
    flex: 1;
    }

    /* Utility Classes */
    .hidden {
    display: none !important;
    }

    .text-center {
    text-align: center;
    }

    .hint {
    font-size: 12px;
    color: var(--muted);
    margin: var(--spacing-sm) 0;
    }

    .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
    }

    /* Loading Indicator */
    #loading-indicator {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    }

    #loading-indicator.active {
    display: flex;
    }

    .spinner {
    width: 40px;
    height: 40px;
    border: 4px solid var(--acc);
    border-radius: 50%;
    border-top-color: transparent;
    animation: spin 1s linear infinite;
    }

    @keyframes spin {
    to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- Loading Indicator -->
  <div id="loading-indicator">
    <div class="spinner"></div>
  </div>

  <header>
    <h1>Трекер тренировок</h1>
    <div class="muted">Один день = одна тренировка. Сохранение в Telegram CloudStorage</div>

    <div class="controls" id="controls-workout">
      <label for="date">Дата:</label>
      <input type="date" id="date" aria-label="Выбор даты тренировки" />
      <button id="save" type="button">Сохранить</button>
      <button id="clear" type="button" class="ghost">Очистить день</button>
    </div>

    <div class="tabs" role="tablist">
      <button class="tab-btn active" data-tab="workout" role="tab" aria-selected="true" aria-controls="tab-workout">
        Тренировка
      </button>
      <button class="tab-btn" data-tab="history" role="tab" aria-selected="false" aria-controls="tab-history">
        История
      </button>
      <button class="tab-btn" data-tab="stats" role="tab" aria-selected="false" aria-controls="tab-stats">
        Статистика
      </button>
    </div>
  </header>

  <main>
    <!-- Вкладка: Тренировка -->
    <section id="tab-workout" class="tab active" role="tabpanel" aria-labelledby="tab-workout">
      <div class="stats">
        <div class="stat">
          <h3>Тоннаж</h3>
          <p id="statVolume">0 кг</p>
        </div>
        <div class="stat">
          <h3>Повторы</h3>
          <p id="statReps">0</p>
        </div>
        <div class="stat">
          <h3>Макс. вес</h3>
          <p id="statMax">0 кг</p>
        </div>
      </div>

      <div class="hint">
        Тап по числу — колесо выбора. Кнопки +/- — быстрый шаг. Новый подход копирует вес предыдущего.
      </div>

      <div id="blocks" class="blocks"></div>
    </section>

    <!-- Вкладка: История -->
    <section id="tab-history" class="tab" role="tabpanel" aria-labelledby="tab-history">
      <div id="history-list" class="list" role="list"></div>
    </section>

    <!-- Вкладка: Статистика -->
    <section id="tab-stats" class="tab" role="tabpanel" aria-labelledby="tab-stats">
      <div class="stat-cards">
        <div class="card">
          <h3>Всего тренировок</h3>
          <div class="metric" id="st-total-workouts">0</div>
        </div>
        <div class="card">
          <h3>Общий тоннаж</h3>
          <div class="metric" id="st-total-volume">0 кг</div>
        </div>
        <div class="card">
          <h3>Средний тоннаж</h3>
          <div class="metric" id="st-avg-volume">0 кг</div>
        </div>
        <div class="card">
          <h3>Лучший день (тоннаж)</h3>
          <div class="metric" id="st-best-volume">0 кг</div>
        </div>
      </div>

      <div class="card">
        <h3>Топ упражнений</h3>
        <div class="list" id="st-top-exercises" role="list"></div>
      </div>

      <div class="card" style="margin-top: var(--spacing-md);">
        <h3>Рекорды (макс. вес)</h3>
        <div class="list" id="st-records" role="list"></div>
      </div>
    </section>
  </main>

  <!-- Кнопки добавления -->
  <div class="page-actions" id="page-actions">
    <button id="addSingle" type="button" class="ghost" aria-describedby="add-single-help">+ Упражнение</button>
    <button id="addSuperset" type="button" class="ghost" aria-describedby="add-superset-help">+ Суперсет</button>
  </div>

  <!-- Скрытые подсказки для доступности -->
  <div id="add-single-help" class="sr-only">Добавляет новое упражнение к тренировке</div>
  <div id="add-superset-help" class="sr-only">Добавляет суперсет из двух упражнений</div>

  <!-- Модальные окна -->
  <!-- Модалка: сводка тренировки (История) -->
  <div class="modal" id="history-modal" aria-hidden="true" role="dialog" aria-labelledby="history-title">
    <div class="sheet">
      <div class="sheet-header">
        <div class="sheet-title" id="history-title">Тренировка</div>
        <div class="sheet-actions-inline">
          <button class="btn-cancel" id="history-close" type="button">Закрыть</button>
        </div>
      </div>
      <div id="history-content" class="sheet-content"></div>
    </div>
  </div>

  <!-- Модалка: выбор значения -->
  <div class="modal" id="picker-modal" aria-hidden="true" role="dialog" aria-labelledby="picker-title">
    <div class="sheet">
      <div class="sheet-header">
        <div class="sheet-title" id="picker-title">Выбор значения</div>
        <div class="sheet-actions-inline">
          <button class="btn-cancel" id="picker-cancel" type="button">Отмена</button>
          <button class="btn-ok" id="picker-ok" type="button">OK</button>
        </div>
      </div>
      <div class="center-line">
        <div class="picker" id="picker-list" role="listbox"></div>
      </div>
    </div>
  </div>

  <!-- Шаблоны -->
  <template id="set-template">
    <div class="set">
      <div class="num">Подход 1</div>
      <div class="row">
        <div class="num-input" data-type="weight" data-step="2.5">
          <button class="minus" type="button" aria-label="Уменьшить вес">−</button>
          <div class="value" role="button" tabindex="0" aria-label="Вес">0</div>
          <div class="unit">кг</div>
          <button class="plus" type="button" aria-label="Увеличить вес">+</button>
        </div>
        <div class="num-input" data-type="reps" data-step="1">
          <button class="minus" type="button" aria-label="Уменьшить повторения">−</button>
          <div class="value" role="button" tabindex="0" aria-label="Повторы">0</div>
          <div class="unit">×</div>
          <button class="plus" type="button" aria-label="Увеличить повторения">+</button>
        </div>
      </div>
      <button class="rm" type="button" title="Удалить подход" aria-label="Удалить подход">×</button>
    </div>
  </template>

  <!-- Список упражнений -->
  <datalist id="exercise-suggestions">
    <!-- Грудь -->
    <option value="Жим лежа штанга"></option>
    <option value="Жим лежа гантели"></option>
    <option value="Жим на наклонной скамье штанга"></option>
    <option value="Жим на наклонной скамье гантели"></option>
    <option value="Разводка гантелей лежа"></option>
    <option value="Сведение рук в тренажере (бабочка)"></option>
    <option value="Отжимания от пола"></option>
    <option value="Отжимания на брусьях (грудь)"></option>
    <!-- Спина -->
    <option value="Подтягивания широким хватом"></option>
    <option value="Подтягивания узким хватом"></option>
    <option value="Тяга верхнего блока"></option>
    <option value="Тяга горизонтального блока"></option>
    <option value="Тяга штанги в наклоне"></option>
    <option value="Тяга гантели в наклоне"></option>
    <option value="Тяга Т-грифа"></option>
    <option value="Пуловер с гантелью"></option>
    <option value="Гиперэкстензия"></option>
    <!-- Ноги -->
    <option value="Приседания со штангой"></option>
    <option value="Фронтальные приседания"></option>
    <option value="Приседания с гантелями"></option>
    <option value="Жим ногами"></option>
    <option value="Выпады с гантелями"></option>
    <option value="Болгарские сплит-приседания"></option>
    <option value="Сгибания ног лежа"></option>
    <option value="Разгибания ног сидя"></option>
    <option value="Подъем на носки стоя (икры)"></option>
    <option value="Подъем на носки сидя (икры)"></option>
    <option value="Румынская тяга со штангой"></option>
    <option value="Румынская тяга с гантелями"></option>
    <!-- Плечи -->
    <option value="Жим гантелей сидя"></option>
    <option value="Жим штанги стоя"></option>
    <option value="Махи гантелями в стороны"></option>
    <option value="Махи гантелями вперед"></option>
    <option value="Тяга штанги к подбородку"></option>
    <option value="Обратные махи (задняя дельта)"></option>
    <option value="Тяга каната к лицу (Face Pull)"></option>
    <!-- Руки -->
    <option value="Подъем штанги на бицепс"></option>
    <option value="Подъем гантелей на бицепс"></option>
    <option value="Молотки с гантелями"></option>
    <option value="Французский жим штанги"></option>
    <option value="Французский жим гантели"></option>
    <option value="Разгибания рук на блоке (трицепс)"></option>
    <option value="Отжимания на брусьях (трицепс)"></option>
    <!-- Пресс -->
    <option value="Скручивания на полу"></option>
    <option value="Скручивания на фитболе"></option>
    <option value="Подъем ног в висе"></option>
    <option value="Планка"></option>
    <option value="Велосипед (пресс)"></option>
    <option value="Русский твист"></option>
  </datalist>

  <script>
// Constants
const CONSTANTS = {
  MAX_WORKOUTS: 300,
  ITEM_HEIGHT: 40,
  PICKER_CENTER_OFFSET: 80,
  MAX_WEIGHT: 300,
  MAX_REPS: 50,
  WEIGHT_STEP: 2.5,
  REPS_STEP: 1,
  AUTOSAVE_DELAY: 1000,
  BUTTON_DEBOUNCE: 150,
  STORAGE_KEYS: {
    WORKOUTS: 'workouts',
    DRAFT: 'draftWorkout',
    LAST_DATE: 'lastWorkoutDate'
  }
};

// Loading Indicator
const loadingIndicator = {
  show() {
    const indicator = document.getElementById('loading-indicator');
    if (indicator) {
      indicator.classList.add('active');
    }
  },
  hide() {
    const indicator = document.getElementById('loading-indicator');
    if (indicator) {
      indicator.classList.remove('active');
    }
  }
};

// Telegram initialization
let tg = window.Telegram?.WebApp;
if (!tg) {
    console.error('Telegram WebApp не доступен');
    document.body.innerHTML = '<div style="padding: 20px; text-align: center;">Приложение должно быть открыто в Telegram</div>';
} else {
    try {
      tg.ready();
      tg.expand();
      
      if (tg.setHeaderColor) tg.setHeaderColor('#171a21');
      if (tg.setBackgroundColor) tg.setBackgroundColor('#0f1115');
    } catch (error) {
      console.warn('Ошибка инициализации Telegram WebApp:', error);
    }
}

// Helper Functions
const helpers = {
  qs(selector, root = document) {
    try {
      return root.querySelector(selector);
    } catch (e) {
      console.error(`Error querying selector "${selector}":`, e);
      return null;
    }
  },

  qsa(selector, root = document) {
    try {
      return Array.from(root.querySelectorAll(selector));
    } catch (e) {
      console.error(`Error querying selector "${selector}":`, e);
      return [];
    }
  },

  escapeHtml(str = '') {
    if (typeof str !== 'string') {
      return String(str);
    }
    const htmlEntities = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return str.replace(/[&<>"']/g, char => htmlEntities[char]);
  },

  todayISO() {
    try {
      const d = new Date();
      const offset = d.getTimezoneOffset() * 60000;
      return new Date(Date.now() - offset).toISOString().slice(0, 10);
    } catch (e) {
      console.error('Error getting today ISO date:', e);
      return new Date().toISOString().slice(0, 10);
    }
  },

  formatDate(dateStr) {
    try {
      if (!dateStr) return '';
      return new Date(dateStr).toLocaleDateString('ru-RU');
    } catch (e) {
      console.error('Error formatting date:', e);
      return dateStr;
    }
  },

  safeParseFloat(value, defaultValue = 0) {
    if (value === null || value === undefined || value === '') {
      return defaultValue;
    }
    const parsed = parseFloat(value);
    return isNaN(parsed) ? defaultValue : parsed;
  },

  safeParseInt(value, defaultValue = 0) {
    if (value === null || value === undefined || value === '') {
      return defaultValue;
    }
    const parsed = parseInt(value, 10);
    return isNaN(parsed) ? defaultValue : parsed;
  },

  round(value, decimals = 1) {
    if (typeof value !== 'number' || isNaN(value)) return 0;
    const multiplier = Math.pow(10, decimals);
    return Math.round(value * multiplier) / multiplier;
  },

  haptic(type = 'light') {
    try {
      if (tg?.HapticFeedback) {
        tg.HapticFeedback.impactOccurred(type);
      }
    } catch (e) {
      console.error('Error triggering haptic feedback:', e);
    }
  },

  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  },

  throttle(func, limit) {
    let lastFunc;
    let lastRan;
    return function executedFunction(...args) {
      if (!lastRan) {
        func(...args);
        lastRan = Date.now();
      } else {
        clearTimeout(lastFunc);
        lastFunc = setTimeout(() => {
          if ((Date.now() - lastRan) >= limit) {
            func(...args);
            lastRan = Date.now();
          }
        }, limit - (Date.now() - lastRan));
      }
    };
  }
};

// Error Handler
const errorHandler = {
  handle(error, context) {
    console.error(`Error in ${context}:`, error);
    
    if (tg?.showAlert) {
      tg.showAlert(`Произошла ошибка: ${error.message}`);
    }
    
    loadingIndicator.hide();
  },

  showError(message) {
    if (tg?.showAlert) {
      tg.showAlert(message);
    } else {
      alert(message);
    }
  }
};

// Storage Service
const storageService = {
    async isAvailable() {
      try {
        if (!tg?.CloudStorage) {
          return false;
        }
        const testKey = '_test_storage_';
        await new Promise((resolve, reject) => {
          tg.CloudStorage.setItem(testKey, '1', error => {
            if (error) reject(error);
            else resolve();
          });
        });
        await new Promise((resolve, reject) => {
          tg.CloudStorage.removeItem(testKey, error => {
            if (error) reject(error);
            else resolve();
          });
        });
        return true;
      } catch (e) {
        console.warn('CloudStorage недоступен:', e);
        return false;
      }
    },

    async save(key, value) {
      try {
        if (!tg?.CloudStorage) {
          throw new Error('CloudStorage недоступен');
        }

        const stringValue = JSON.stringify(value);
        if (stringValue.length > 512000) {
          throw new Error('Превышен размер данных для сохранения');
        }

        await new Promise((resolve, reject) => {
          tg.CloudStorage.setItem(key, stringValue, error => {
            if (error) reject(new Error(error));
            else resolve();
          });
        });
      } catch (error) {
        console.error('Ошибка сохранения в CloudStorage:', error);
        throw error;
      }
    },

    async load(key) {
      try {
        if (!tg?.CloudStorage) {
          return null;
        }

        const value = await new Promise((resolve, reject) => {
          tg.CloudStorage.getItem(key, (error, value) => {
            if (error) reject(new Error(error));
            else resolve(value);
          });
        });
        return value ? JSON.parse(value) : null;
      } catch (error) {
        console.error('Ошибка загрузки из CloudStorage:', error);
        return null;
      }
    },

    async remove(key) {
      try {
        if (!tg?.CloudStorage) {
          return;
        }
        await new Promise((resolve, reject) => {
          tg.CloudStorage.removeItem(key, error => {
            if (error) reject(new Error(error));
            else resolve();
          });
        });
      } catch (error) {
        console.error('Ошибка удаления из CloudStorage:', error);
      }
    }
};

// UI Controller
const uiController = {
  elements: {
    date: null,
    blocks: null,
    pageActions: null,
    stats: {
      volume: null,
      reps: null,
      max: null
    },
    picker: {
      modal: null,
      list: null,
      ok: null,
      cancel: null
    },
    history: {
      modal: null,
      list: null,
      content: null,
      close: null
    },
    tabs: {
      buttons: [],
      panels: []
    }
  },

  init() {
    try {
      this.cacheElements();
      this.validateElements();
      this.setupEventListeners();
      this.initTabs();
    } catch (error) {
      errorHandler.handle(error, 'UI initialization');
    }
  },

  cacheElements() {
    this.elements.date = helpers.qs('#date');
    this.elements.blocks = helpers.qs('#blocks');
    this.elements.pageActions = helpers.qs('#page-actions');
    
    this.elements.stats.volume = helpers.qs('#statVolume');
    this.elements.stats.reps = helpers.qs('#statReps');
    this.elements.stats.max = helpers.qs('#statMax');
    
    this.elements.picker.modal = helpers.qs('#picker-modal');
    this.elements.picker.list = helpers.qs('#picker-list');
    this.elements.picker.ok = helpers.qs('#picker-ok');
    this.elements.picker.cancel = helpers.qs('#picker-cancel');
    
    this.elements.history.modal = helpers.qs('#history-modal');
    this.elements.history.list = helpers.qs('#history-list');
    this.elements.history.content = helpers.qs('#history-content');
    this.elements.history.close = helpers.qs('#history-close');
    
    this.elements.tabs.buttons = helpers.qsa('.tab-btn');
    this.elements.tabs.panels = helpers.qsa('.tab');
  },

  validateElements() {
    const requiredElements = [
      'date', 'blocks', 'pageActions',
      'stats.volume', 'stats.reps', 'stats.max',
      'picker.modal', 'picker.list', 'picker.ok', 'picker.cancel',
      'history.modal', 'history.list', 'history.content', 'history.close'
    ];

    for (const path of requiredElements) {
      let element = this.elements;
      const parts = path.split('.');
      for (const part of parts) {
        element = element[part];
      }
      if (!element) {
        throw new Error(`Required element not found: ${path}`);
      }
    }
  },

  setupEventListeners() {
    // Обработчики вкладок
    this.elements.tabs.buttons.forEach(btn => {
      btn.addEventListener('click', () => this.switchTab(btn.dataset.tab));
    });

    // Обработчики модальных окон
    if (this.elements.history.close) {
      this.elements.history.close.addEventListener('click', () => {
        this.elements.history.modal.classList.remove('active');
        this.elements.history.modal.setAttribute('aria-hidden', 'true');
      });
    }

    if (this.elements.picker.ok) {
      this.elements.picker.ok.addEventListener('click', () => {
        this.elements.picker.modal.classList.remove('active');
        this.elements.picker.modal.setAttribute('aria-hidden', 'true');
        const selectedValue = this.getSelectedPickerValue();
        if (this.onPickerSelect) {
          this.onPickerSelect(selectedValue);
        }
      });
    }

    if (this.elements.picker.cancel) {
      this.elements.picker.cancel.addEventListener('click', () => {
        this.elements.picker.modal.classList.remove('active');
        this.elements.picker.modal.setAttribute('aria-hidden', 'true');
      });
    }

    // Закрытие модалок по клику вне
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal')) {
        e.target.classList.remove('active');
        e.target.setAttribute('aria-hidden', 'true');
      }
    });

    // Закрытие по Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const activeModal = helpers.qs('.modal.active');
        if (activeModal) {
          activeModal.classList.remove('active');
          activeModal.setAttribute('aria-hidden', 'true');
        }
      }
    });
  },

  initTabs() {
    this.elements.tabs.buttons.forEach(btn => {
      btn.setAttribute('aria-selected', 'false');
      btn.setAttribute('tabindex', '-1');
    });
    
    this.elements.tabs.panels.forEach(panel => {
      panel.setAttribute('hidden', '');
      panel.classList.remove('active');
    });

    // Активируем первую вкладку
    const firstTab = this.elements.tabs.buttons[0];
    if (firstTab) {
      this.switchTab(firstTab.dataset.tab);
    }
  },

  switchTab(tabId) {
    if (!tabId) return;

    this.elements.tabs.buttons.forEach(btn => {
      const isActive = btn.dataset.tab === tabId;
      btn.classList.toggle('active', isActive);
      btn.setAttribute('aria-selected', isActive);
      btn.setAttribute('tabindex', isActive ? '0' : '-1');
    });

    this.elements.tabs.panels.forEach(panel => {
      const isActive = panel.id === `tab-${tabId}`;
      panel.classList.toggle('active', isActive);
      if (isActive) {
        panel.removeAttribute('hidden');
      } else {
        panel.setAttribute('hidden', '');
      }
    });

    // Обновляем UI в зависимости от вкладки
    if (this.elements.pageActions) {
      this.elements.pageActions.style.display = tabId === 'workout' ? 'flex' : 'none';
    }

    // Загружаем данные для вкладки
    if (tabId === 'history') {
      historyController.loadHistory();
    } else if (tabId === 'stats') {
      statsController.loadStats();
    }
  },

  updateStats: helpers.debounce(function() {
    try {
      let volume = 0, reps = 0, maxWeight = 0;
      
      helpers.qsa('.set').forEach(set => {
        const weightEl = helpers.qs('.num-input[data-type="weight"] .value', set);
        const repsEl = helpers.qs('.num-input[data-type="reps"] .value', set);
        
        if (!weightEl || !repsEl) {
          console.warn('Missing weight or reps element in set');
          return;
        }

        const weight = helpers.safeParseFloat(weightEl.textContent);
        const r = helpers.safeParseInt(repsEl.textContent);

        if (weight > 0 && r > 0) {
          volume += weight * r;
          reps += r;
          if (weight > maxWeight) maxWeight = weight;
        }
      });

      // Безопасное обновление элементов статистики
      const elements = uiController.elements.stats;
      if (elements.volume) elements.volume.textContent = `${helpers.round(volume)} кг`;
      if (elements.reps) elements.reps.textContent = String(reps);
      if (elements.max) elements.max.textContent = `${maxWeight} кг`;
    } catch (error) {
      errorHandler.handle(error, 'Update stats');
    }
  }, 100),

  showPicker(values, initialValue, onSelect) {
    try {
      if (!Array.isArray(values) || !values.length) {
        console.warn('Invalid values for picker');
        return;
      }

      this.elements.picker.list.innerHTML = values.map(v => 
        `<div class="picker-item" role="option" ${v === initialValue ? 'aria-selected="true"' : ''}>${helpers.escapeHtml(String(v))}</div>`
      ).join('');

      const selectedIndex = values.indexOf(initialValue);
      if (selectedIndex !== -1) {
        const scrollTop = selectedIndex * CONSTANTS.ITEM_HEIGHT - CONSTANTS.PICKER_CENTER_OFFSET;
        this.elements.picker.list.scrollTop = Math.max(0, scrollTop);
      }

      this.onPickerSelect = onSelect;
      this.elements.picker.modal.classList.add('active');
      this.elements.picker.modal.setAttribute('aria-hidden', 'false');
    } catch (error) {
      errorHandler.handle(error, 'Show picker');
    }
  },

  getSelectedPickerValue() {
    try {
      const list = this.elements.picker.list;
      if (!list) return '';

      const centerY = list.offsetHeight / 2;
      const elements = Array.from(list.children);
      
      return elements.reduce((closest, el) => {
        const rect = el.getBoundingClientRect();
        const listRect = list.getBoundingClientRect();
        const elCenterY = rect.top - listRect.top + rect.height / 2;
        const distance = Math.abs(centerY - elCenterY);
        
        if (!closest || distance < closest.distance) {
          return { element: el, distance };
        }
        return closest;
      }, null)?.element?.textContent || '';
    } catch (error) {
      errorHandler.handle(error, 'Get selected picker value');
      return '';
    }
  },

  showHistoryModal(workout) {
    try {
      if (!workout) {
        errorHandler.showError('Данные тренировки не найдены');
        return;
      }

      const content = this.generateWorkoutSummary(workout);
      this.elements.history.content.innerHTML = content;
      this.elements.history.modal.classList.add('active');
      this.elements.history.modal.setAttribute('aria-hidden', 'false');
    } catch (error) {
      errorHandler.handle(error, 'Show history modal');
    }
  },

  generateWorkoutSummary(workout) {
    try {
      if (!workout || !workout.exercises) {
        return '<div class="error">Нет данных о тренировке</div>';
      }

      let html = `<div class="workout-summary">`;
      html += `<div class="date">${helpers.formatDate(workout.date)}</div>`;

      // Статистика
      html += `<div class="stats">
        <div class="stat">
          <div class="label">Тоннаж</div>
          <div class="value">${helpers.round(workout.stats?.volume || 0)} кг</div>
        </div>
        <div class="stat">
          <div class="label">Повторы</div>
          <div class="value">${workout.stats?.reps || 0}</div>
        </div>
        <div class="stat">
          <div class="label">Макс. вес</div>
          <div class="value">${workout.stats?.maxWeight || 0} кг</div>
        </div>
      </div>`;

      // Упражнения
      if (workout.exercises && workout.exercises.length) {
        workout.exercises.forEach((block, blockIndex) => {
          html += `<div class="block">`;
          
          if (block.exercises && block.exercises.length) {
            block.exercises.forEach((ex, exIndex) => {
              html += `<div class="exercise">
                <div class="name">${helpers.escapeHtml(ex.name || 'Без названия')}</div>
                <div class="sets">`;
              
              if (ex.sets && ex.sets.length) {
                ex.sets.forEach((set, setIndex) => {
                  html += `<div class="set">
                    <span class="num">${setIndex + 1}.</span>
                    <span class="weight">${helpers.safeParseFloat(set.weight)} кг</span>
                    <span class="reps">×${helpers.safeParseInt(set.reps)}</span>
                  </div>`;
                });
              }
              
              html += `</div></div>`;
            });
          }
          
          html += `</div>`;
        });
      }

      html += `</div>`;
      return html;
    } catch (error) {
      errorHandler.handle(error, 'Generate workout summary');
      return '<div class="error">Ошибка при формировании сводки тренировки</div>';
    }
  }
};

// Exercise Controller
const exerciseController = {
  createBlock(type = 'single') {
    try {
      const block = document.createElement('div');
      block.className = 'block';
      block.setAttribute('data-type', type);
      
      const header = document.createElement('div');
      header.className = 'block-header';
      
      const title = document.createElement('div');
      title.className = 'block-title';
      
      const actions = document.createElement('div');
      actions.className = 'block-actions';
      
      const addSet = document.createElement('button');
      addSet.type = 'button';
      addSet.className = 'ghost';
      addSet.textContent = '+ Подход';
      addSet.setAttribute('aria-label', 'Добавить подход');
      addSet.addEventListener('click', (e) => {
        e.stopPropagation();
        this.addSet(block);
      });
      
      const remove = document.createElement('button');
      remove.type = 'button';
      remove.className = 'ghost danger';
      remove.textContent = 'Удалить';
      remove.setAttribute('aria-label', 'Удалить блок упражнений');
      remove.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm('Удалить блок упражнений?')) {
          block.remove();
          uiController.updateStats();
          helpers.haptic('medium');
        }
      });
      
      actions.append(addSet, remove);
      header.append(title, actions);
      block.appendChild(header);
      
      if (type === 'single') {
        const exercise = this.createExercise();
        if (exercise) {
          block.appendChild(exercise);
          title.textContent = 'Упражнение';
        }
      } else {
        const exercises = document.createElement('div');
        exercises.className = 'exercises';
        const ex1 = this.createExercise();
        const ex2 = this.createExercise();
        if (ex1 && ex2) {
          exercises.append(ex1, ex2);
          block.appendChild(exercises);
          title.textContent = 'Суперсет';
        }
      }
      
      return block;
    } catch (error) {
      errorHandler.handle(error, 'Create block');
      return null;
    }
  },

  createExercise() {
    try {
      const exercise = document.createElement('div');
      exercise.className = 'exercise';
      
      const name = document.createElement('input');
      name.type = 'text';
      name.className = 'exercise-name';
      name.placeholder = 'Название упражнения';
      name.setAttribute('list', 'exercise-suggestions');
      name.setAttribute('aria-label', 'Название упражнения');
      
      // Автосохранение при изменении названия
      name.addEventListener('input', helpers.debounce(() => {
        workoutController.saveDraft();
      }, CONSTANTS.AUTOSAVE_DELAY));
      
      const sets = document.createElement('div');
      sets.className = 'sets';
      
      exercise.append(name, sets);
      this.addSet(exercise);
      
      return exercise;
    } catch (error) {
      errorHandler.handle(error, 'Create exercise');
      return null;
    }
  },

  addSet(parent) {
    try {
      const template = document.getElementById('set-template');
      if (!template) {
        throw new Error('Set template not found');
      }
      
      let sets;
      if (parent.classList.contains('block')) {
        // Это блок - ищем первое упражнение
        const firstExercise = helpers.qs('.exercise', parent);
        if (!firstExercise) return null;
        sets = helpers.qs('.sets', firstExercise);
      } else {
        // Это упражнение
        sets = helpers.qs('.sets', parent);
      }
      
      if (!sets) {
        throw new Error('Sets container not found');
      }
      
      const clone = template.content.cloneNode(true);
      const set = clone.querySelector('.set');
      if (!set) {
        throw new Error('Set element not found in template');
      }
      
      // Копируем вес из предыдущего подхода
      const prevSet = sets.querySelector('.set:last-child');
      if (prevSet) {
        const prevWeight = helpers.qs('.num-input[data-type="weight"] .value', prevSet);
        const newWeight = helpers.qs('.num-input[data-type="weight"] .value', set);
        if (prevWeight && newWeight) {
          newWeight.textContent = prevWeight.textContent || '0';
        }
      }
      
      // Нумерация подходов
      const setNum = sets.children.length + 1;
      const numEl = helpers.qs('.num', set);
      if (numEl) {
        numEl.textContent = `Подход ${setNum}`;
      }
      
      // Обработчики событий
      this.setupSetListeners(set);
      
      sets.appendChild(set);
      uiController.updateStats();
      helpers.haptic('light');
      
      return set;
    } catch (error) {
      errorHandler.handle(error, 'Add set');
      return null;
    }
  },

  setupSetListeners(set) {
    if (!set) return;

    try {
      // Отдельные обработчики для кнопок +/-
      const buttons = helpers.qsa('button', set);
      buttons.forEach(btn => {
        if (btn.classList.contains('plus') || btn.classList.contains('minus')) {
          btn.addEventListener('click', helpers.throttle((e) => {
            e.stopPropagation();
            
            if (btn.disabled) return;
            
            // Блокируем кнопку на короткое время
            btn.disabled = true;
            setTimeout(() => btn.disabled = false, CONSTANTS.BUTTON_DEBOUNCE);

            const wrap = btn.closest('.num-input');
            if (!wrap) return;

            const valEl = wrap.querySelector('.value');
            if (!valEl) return;

            const val = helpers.safeParseFloat(valEl.textContent);
            const step = helpers.safeParseFloat(wrap.dataset.step) || 1;
            const isWeight = wrap.dataset.type === 'weight';
            const max = isWeight ? CONSTANTS.MAX_WEIGHT : CONSTANTS.MAX_REPS;

            const newVal = btn.classList.contains('plus') 
              ? Math.min(val + step, max)
              : Math.max(0, val - step);

            valEl.textContent = isWeight ? helpers.round(newVal) : Math.round(newVal);
            uiController.updateStats();
            helpers.haptic('light');
          }, 50));
        }
      });

      // Обработка значений через пикер
      helpers.qsa('.value', set).forEach(el => {
        // Клик
        el.addEventListener('click', () => {
          const wrap = el.closest('.num-input');
          if (!wrap) return;

          const isWeight = wrap.dataset.type === 'weight';
          const step = helpers.safeParseFloat(wrap.dataset.step) || 1;
          const max = isWeight ? CONSTANTS.MAX_WEIGHT : CONSTANTS.MAX_REPS;
          const currentValue = helpers.safeParseFloat(el.textContent);

          const values = [];
          for (let i = 0; i <= max; i += step) {
            values.push(isWeight ? helpers.round(i) : Math.round(i));
          }

          uiController.showPicker(values, currentValue, (value) => {
            const numValue = helpers.safeParseFloat(value);
            el.textContent = isWeight ? helpers.round(numValue) : Math.round(numValue);
            uiController.updateStats();
            helpers.haptic('medium');
          });
        });

        // Доступность: Enter и Space
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            e.target.click();
          }
        });
      });

      // Удаление подхода
      const rmBtn = helpers.qs('.rm', set);
      if (rmBtn) {
        rmBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const sets = set.closest('.sets');
          set.remove();
          
          // Обновляем нумерацию
          if (sets) {
            helpers.qsa('.set', sets).forEach((set, i) => {
              const numEl = helpers.qs('.num', set);
              if (numEl) {
                numEl.textContent = `Подход ${i + 1}`;
              }
            });
          }
          
          uiController.updateStats();
          helpers.haptic('medium');
        });
      }
    } catch (error) {
      errorHandler.handle(error, 'Setup set listeners');
    }
  }
};

// Workout Controller
const workoutController = {
  debouncedSaveDraft: null,

  async init() {
    try {
      // Создаем дебаунсированную функцию автосохранения
      this.debouncedSaveDraft = helpers.debounce(() => this.saveDraft(), CONSTANTS.AUTOSAVE_DELAY);

      // Инициализация даты
      const today = helpers.todayISO();
      if (uiController.elements.date) {
        uiController.elements.date.value = today;
        uiController.elements.date.max = today;
      }

      // Загрузка черновика или создание новой тренировки
      const draft = await storageService.load(CONSTANTS.STORAGE_KEYS.DRAFT);
      if (draft && draft.date === today) {
        this.loadWorkout(draft);
      }

      // Автосохранение каждые 30 секунд
      setInterval(() => this.saveDraft(), 30000);
    } catch (error) {
      errorHandler.handle(error, 'Workout controller init');
    }
  },

  async saveDraft() {
    try {
      const workout = this.getWorkoutData();
      if (workout && workout.exercises && workout.exercises.length > 0) {
        await storageService.save(CONSTANTS.STORAGE_KEYS.DRAFT, workout);
      }
    } catch (error) {
      console.warn('Error saving draft:', error);
    }
  },

  async saveWorkout() {
    try {
      loadingIndicator.show();

      const workout = this.getWorkoutData();
      if (!workout) {
        throw new Error('Нет данных для сохранения');
      }

      if (!this.validateWorkout(workout)) {
        throw new Error('Заполните все упражнения и подходы');
      }

      // Загружаем существующие тренировки
      let workouts = await storageService.load(CONSTANTS.STORAGE_KEYS.WORKOUTS) || [];
      
      // Ограничиваем количество сохраненных тренировок
      if (workouts.length >= CONSTANTS.MAX_WORKOUTS) {
        workouts = workouts.slice(-CONSTANTS.MAX_WORKOUTS + 1);
      }

      // Добавляем новую тренировку
      const existingIndex = workouts.findIndex(w => w.date === workout.date);
      if (existingIndex !== -1) {
        workouts[existingIndex] = workout;
      } else {
        workouts.push(workout);
      }

      // Сортируем по дате
      workouts.sort((a, b) => new Date(b.date) - new Date(a.date));

      // Сохраняем
      await storageService.save(CONSTANTS.STORAGE_KEYS.WORKOUTS, workouts);
      await storageService.remove(CONSTANTS.STORAGE_KEYS.DRAFT);

      if (tg?.showPopup) {
        tg.showPopup({
          title: 'Успех',
          message: 'Тренировка сохранена',
          buttons: [{type: 'ok'}]
        });
      } else {
        errorHandler.showError('Тренировка сохранена');
      }

      // Очищаем форму если это сегодняшняя тренировка
      if (workout.date === helpers.todayISO()) {
        this.clearWorkout();
      }
    } catch (error) {
      errorHandler.handle(error, 'Save workout');
    } finally {
      loadingIndicator.hide();
    }
  },

  loadWorkout(workout) {
    try {
      if (uiController.elements.blocks) {
        uiController.elements.blocks.innerHTML = '';
      }
      
      if (!workout || !workout.exercises || !Array.isArray(workout.exercises)) {
        return;
      }
      
      workout.exercises.forEach(block => {
        if (!block.exercises || !Array.isArray(block.exercises)) return;

        const blockEl = exerciseController.createBlock(
          block.exercises.length > 1 ? 'superset' : 'single'
        );
        
        if (!blockEl) return;
        
        const exercises = helpers.qsa('.exercise', blockEl);
        block.exercises.forEach((ex, i) => {
          const exercise = exercises[i];
          if (!exercise || !ex) return;
          
          // Название
          const nameInput = helpers.qs('.exercise-name', exercise);
          if (nameInput && ex.name) {
            nameInput.value = ex.name;
          }
          
          // Подходы
          const sets = helpers.qs('.sets', exercise);
          if (!sets || !ex.sets || !Array.isArray(ex.sets)) return;
          
          sets.innerHTML = '';
          ex.sets.forEach(set => {
            if (!set || typeof set !== 'object') return;

            const setEl = exerciseController.addSet(exercise);
            if (!setEl) return;
            
            const weightVal = helpers.qs('.num-input[data-type="weight"] .value', setEl);
            const repsVal = helpers.qs('.num-input[data-type="reps"] .value', setEl);
            
            if (weightVal && set.weight !== undefined) {
              weightVal.textContent = helpers.round(helpers.safeParseFloat(set.weight));
            }
            if (repsVal && set.reps !== undefined) {
              repsVal.textContent = Math.round(helpers.safeParseInt(set.reps));
            }
          });
        });
        
        if (uiController.elements.blocks) {
          uiController.elements.blocks.appendChild(blockEl);
        }
      });
      
      uiController.updateStats();
    } catch (error) {
      errorHandler.handle(error, 'Load workout');
    }
  },

  clearWorkout() {
    try {
      if (tg?.showConfirm) {
        tg.showConfirm('Очистить все упражнения?', (confirmed) => {
          if (confirmed) {
            this.performClear();
          }
        });
      } else if (confirm('Очистить все упражнения?')) {
        this.performClear();
      }
    } catch (error) {
      errorHandler.handle(error, 'Clear workout');
    }
  },

  performClear() {
    try {
      if (uiController.elements.blocks) {
        uiController.elements.blocks.innerHTML = '';
      }
      uiController.updateStats();
      storageService.remove(CONSTANTS.STORAGE_KEYS.DRAFT).catch(console.warn);
      helpers.haptic('medium');
    } catch (error) {
      errorHandler.handle(error, 'Perform clear');
    }
  },

  getWorkoutData() {
    try {
      const blocks = helpers.qsa('.block');
      if (!blocks.length) return null;

      const exercises = [];
      let totalVolume = 0;
      let totalReps = 0;
      let maxWeight = 0;

      blocks.forEach(block => {
        const blockExercises = [];
        
        helpers.qsa('.exercise', block).forEach(ex => {
          const nameInput = helpers.qs('.exercise-name', ex);
          const name = nameInput?.value?.trim();
          if (!name) return;
          
          const sets = [];
          helpers.qsa('.set', ex).forEach(set => {
            const weightEl = helpers.qs('.num-input[data-type="weight"] .value', set);
            const repsEl = helpers.qs('.num-input[data-type="reps"] .value', set);
            
            const weight = helpers.safeParseFloat(weightEl?.textContent);
            const reps = helpers.safeParseInt(repsEl?.textContent);
            
            if (weight > 0 && reps > 0) {
              sets.push({ weight, reps });
              totalVolume += weight * reps;
              totalReps += reps;
              if (weight > maxWeight) maxWeight = weight;
            }
          });
          
          if (sets.length) {
            blockExercises.push({ name, sets });
          }
        });
        
        if (blockExercises.length) {
          exercises.push({ exercises: blockExercises });
        }
      });

      if (!exercises.length) return null;

      const dateEl = uiController.elements.date;
      return {
        date: dateEl ? dateEl.value : helpers.todayISO(),
        exercises,
        stats: {
          volume: totalVolume,
          reps: totalReps,
          maxWeight
        }
      };
    } catch (error) {
      errorHandler.handle(error, 'Get workout data');
      return null;
    }
  },

  validateWorkout(workout) {
    try {
      if (!workout?.exercises?.length) {
        return false;
      }

      return workout.exercises.every(block => 
        block.exercises?.length && 
        block.exercises.every(ex =>
          ex.name?.trim() && 
          ex.sets?.length && 
          ex.sets.every(set => {
            const weight = helpers.safeParseFloat(set.weight);
            const reps = helpers.safeParseInt(set.reps);
            return weight > 0 && reps > 0;
          })
        )
      );
    } catch (error) {
      errorHandler.handle(error, 'Validate workout');
      return false;
    }
  }
};

// History Controller
const historyController = {
  async loadHistory() {
    try {
      loadingIndicator.show();
      
      const workouts = await storageService.load(CONSTANTS.STORAGE_KEYS.WORKOUTS) || [];
      const list = uiController.elements.history.list;
      
      if (!list) {
        throw new Error('History list element not found');
      }
      
      if (!workouts.length) {
        list.innerHTML = '<div class="empty">История пуста</div>';
        return;
      }
      
      list.innerHTML = workouts.map(workout => {
        if (!workout || !workout.exercises) return '';
        
        return `
          <div class="history-item" data-date="${workout.date}" role="button" tabindex="0">
            <div class="main">
              <div class="date">${helpers.formatDate(workout.date)}</div>
              <div class="stats">
                <div class="stat">
                  <span class="label">Тоннаж:</span>
                  <span class="value">${helpers.round(workout.stats?.volume || 0)} кг</span>
                </div>
                <div class="stat">
                  <span class="label">Повторы:</span>
                  <span class="value">${workout.stats?.reps || 0}</span>
                </div>
              </div>
            </div>
            <div class="exercises">
              ${workout.exercises.map(block => 
                block.exercises ? block.exercises.map(ex => 
                  `<div class="exercise">${helpers.escapeHtml(ex.name || 'Без названия')}</div>`
                ).join('') : ''
              ).join('')}
            </div>
          </div>
        `;
      }).filter(Boolean).join('');
      
      // Обработчики для просмотра деталей
      helpers.qsa('.history-item', list).forEach(item => {
        const showDetails = () => {
          const date = item.dataset.date;
          const workout = workouts.find(w => w.date === date);
          if (workout) {
            uiController.showHistoryModal(workout);
          }
        };

        item.addEventListener('click', showDetails);
        item.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            showDetails();
          }
        });
      });
    } catch (error) {
      errorHandler.handle(error, 'Load history');
    } finally {
      loadingIndicator.hide();
    }
  }
};

// Stats Controller
const statsController = {
  async loadStats() {
    try {
      loadingIndicator.show();
      
      const workouts = await storageService.load(CONSTANTS.STORAGE_KEYS.WORKOUTS) || [];
      if (!workouts.length) {
        this.showEmptyStats();
        return;
      }
      
      // Общая статистика
      const totalVolume = workouts.reduce((sum, w) => sum + (w.stats?.volume || 0), 0);
      const avgVolume = totalVolume / workouts.length;
      const bestVolume = Math.max(...workouts.map(w => w.stats?.volume || 0));
      
      this.updateStatElement('#st-total-workouts', workouts.length);
      this.updateStatElement('#st-total-volume', `${helpers.round(totalVolume)} кг`);
      this.updateStatElement('#st-avg-volume', `${helpers.round(avgVolume)} кг`);
      this.updateStatElement('#st-best-volume', `${helpers.round(bestVolume)} кг`);
      
      // Топ упражнений
      const exerciseStats = this.calculateExerciseStats(workouts);
      const topExercises = Object.entries(exerciseStats)
        .sort((a, b) => b[1].volume - a[1].volume)
        .slice(0, 5);
      
      const topExercisesEl = helpers.qs('#st-top-exercises');
      if (topExercisesEl) {
        topExercisesEl.innerHTML = topExercises.map(([name, stats]) => `
          <div class="list-item">
            <div class="name">${helpers.escapeHtml(name)}</div>
            <div class="stats">
              <div class="stat">
                <span class="label">Тоннаж:</span>
                <span class="value">${helpers.round(stats.volume)} кг</span>
              </div>
              <div class="stat">
                <span class="label">Макс.вес:</span>
                <span class="value">${stats.maxWeight} кг</span>
              </div>
            </div>
          </div>
        `).join('');
      }
      
      // Рекорды
      const records = Object.entries(exerciseStats)
        .sort((a, b) => b[1].maxWeight - a[1].maxWeight)
        .slice(0, 5);
      
      const recordsEl = helpers.qs('#st-records');
      if (recordsEl) {
        recordsEl.innerHTML = records.map(([name, stats]) => `
          <div class="list-item">
            <div class="name">${helpers.escapeHtml(name)}</div>
            <div class="value">${stats.maxWeight} кг</div>
          </div>
        `).join('');
      }
    } catch (error) {
      errorHandler.handle(error, 'Load stats');
    } finally {
      loadingIndicator.hide();
    }
  },

  updateStatElement(selector, value) {
    const el = helpers.qs(selector);
    if (el) {
      el.textContent = value;
    }
  },

  calculateExerciseStats(workouts) {
    const stats = {};
    
    try {
      workouts.forEach(workout => {
        if (!workout.exercises || !Array.isArray(workout.exercises)) return;

        workout.exercises.forEach(block => {
          if (!block.exercises || !Array.isArray(block.exercises)) return;

          block.exercises.forEach(ex => {
            if (!ex.name || !ex.sets || !Array.isArray(ex.sets)) return;

            if (!stats[ex.name]) {
              stats[ex.name] = {
                volume: 0,
                maxWeight: 0,
                totalSets: 0
              };
            }
            
            ex.sets.forEach(set => {
              if (!set || typeof set !== 'object') return;

              const weight = helpers.safeParseFloat(set.weight);
              const reps = helpers.safeParseInt(set.reps);

              if (weight > 0 && reps > 0) {
                stats[ex.name].volume += weight * reps;
                stats[ex.name].maxWeight = Math.max(stats[ex.name].maxWeight, weight);
                stats[ex.name].totalSets++;
              }
            });
          });
        });
      });
    } catch (error) {
      errorHandler.handle(error, 'Calculate exercise stats');
    }
    
    return stats;
  },

  showEmptyStats() {
    const elements = [
      '#st-total-workouts',
      '#st-total-volume',
      '#st-avg-volume',
      '#st-best-volume'
    ];
    
    elements.forEach(selector => {
      const el = helpers.qs(selector);
      if (el) {
        el.textContent = selector.includes('volume') ? '0 кг' : '0';
      }
    });

    const listElements = ['#st-top-exercises', '#st-records'];
    listElements.forEach(selector => {
      const el = helpers.qs(selector);
      if (el) {
        el.innerHTML = '<div class="empty">Нет данных</div>';
      }
    });
  }
};

// App Controller
const appController = {
  async init() {
    try {
      // Инициализация UI
      uiController.init();
      
      // Инициализация тренировки
      await workoutController.init();
      
      // Обработчики событий
      this.setupEventListeners();
      
      console.log('App initialized successfully');
    } catch (error) {
      errorHandler.handle(error, 'App initialization');
    }
  },

  setupEventListeners() {
    try {
      // Кнопки добавления упражнений
      const addSingleBtn = helpers.qs('#addSingle');
      if (addSingleBtn) {
        addSingleBtn.addEventListener('click', () => {
          const block = exerciseController.createBlock('single');
          if (block && uiController.elements.blocks) {
            uiController.elements.blocks.appendChild(block);
            helpers.haptic('light');
          }
        });
      }
      
      const addSupersetBtn = helpers.qs('#addSuperset');
      if (addSupersetBtn) {
        addSupersetBtn.addEventListener('click', () => {
          const block = exerciseController.createBlock('superset');
          if (block && uiController.elements.blocks) {
            uiController.elements.blocks.appendChild(block);
            helpers.haptic('light');
          }
        });
      }
      
      // Сохранение тренировки
      const saveBtn = helpers.qs('#save');
      if (saveBtn) {
        saveBtn.addEventListener('click', () => {
          workoutController.saveWorkout();
        });
      }
      
      // Очистка тренировки
      const clearBtn = helpers.qs('#clear');
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          workoutController.clearWorkout();
        });
      }
      
      // Автосохранение при изменении даты
      if (uiController.elements.date) {
        uiController.elements.date.addEventListener('change', () => {
          if (workoutController.debouncedSaveDraft) {
            workoutController.debouncedSaveDraft();
          }
        });
      }

      // Обработка ошибок на уровне приложения
      window.addEventListener('error', (event) => {
        errorHandler.handle(event.error, 'Global error handler');
      });

      window.addEventListener('unhandledrejection', (event) => {
        errorHandler.handle(event.reason, 'Unhandled promise rejection');
      });
    } catch (error) {
      errorHandler.handle(error, 'Setup event listeners');
    }
  }
};

// Запуск приложения
document.addEventListener('DOMContentLoaded', () => {
  appController.init().catch(error => {
    errorHandler.handle(error, 'DOMContentLoaded');
  });
});

// Обработка закрытия приложения
window.addEventListener('beforeunload', () => {
  if (workoutController && workoutController.saveDraft) {
    workoutController.saveDraft().catch(console.warn);
  }
});

// Обработка фокуса/потери фокуса приложения
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Приложение скрыто - сохраняем черновик
    if (workoutController && workoutController.saveDraft) {
      workoutController.saveDraft().catch(console.warn);
    }
  }
});
</script>
</body>
</html>
